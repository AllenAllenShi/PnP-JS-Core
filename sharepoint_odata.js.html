<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: sharepoint/odata.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: sharepoint/odata.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
const util_1 = require("../utils/util");
const logging_1 = require("../utils/logging");
const httpclient_1 = require("../net/httpclient");
const pnplibconfig_1 = require("../configuration/pnplibconfig");
const exceptions_1 = require("../utils/exceptions");
const exceptions_2 = require("../utils/exceptions");
function extractOdataId(candidate) {
    if (candidate.hasOwnProperty("odata.id")) {
        return candidate["odata.id"];
    }
    else if (candidate.hasOwnProperty("__metadata") &amp;&amp; candidate.__metadata.hasOwnProperty("id")) {
        return candidate.__metadata.id;
    }
    else {
        throw new exceptions_1.ODataIdException(candidate);
    }
}
exports.extractOdataId = extractOdataId;
class ODataParserBase {
    parse(r) {
        return new Promise((resolve, reject) => {
            if (this.handleError(r, reject)) {
                if ((r.headers.has("Content-Length") &amp;&amp; parseFloat(r.headers.get("Content-Length")) === 0) || r.status === 204) {
                    resolve({});
                }
                else {
                    r.json().then(json => resolve(this.parseODataJSON(json)));
                }
            }
        });
    }
    handleError(r, reject) {
        if (!r.ok) {
            r.json().then(json => {
                reject(new exceptions_2.ProcessHttpClientResponseException(r.status, r.statusText, json));
            });
        }
        return r.ok;
    }
    parseODataJSON(json) {
        let result = json;
        if (json.hasOwnProperty("d")) {
            if (json.d.hasOwnProperty("results")) {
                result = json.d.results;
            }
            else {
                result = json.d;
            }
        }
        else if (json.hasOwnProperty("value")) {
            result = json.value;
        }
        return result;
    }
}
exports.ODataParserBase = ODataParserBase;
class ODataDefaultParser extends ODataParserBase {
}
exports.ODataDefaultParser = ODataDefaultParser;
class ODataRawParserImpl {
    parse(r) {
        return r.json();
    }
}
exports.ODataRawParserImpl = ODataRawParserImpl;
class ODataValueParserImpl extends ODataParserBase {
    parse(r) {
        return super.parse(r).then(d => d);
    }
}
class ODataEntityParserImpl extends ODataParserBase {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    parse(r) {
        return super.parse(r).then(d => {
            let o = new this.factory(getEntityUrl(d), null);
            return util_1.Util.extend(o, d);
        });
    }
}
class ODataEntityArrayParserImpl extends ODataParserBase {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    parse(r) {
        return super.parse(r).then((d) => {
            return d.map(v => {
                let o = new this.factory(getEntityUrl(v), null);
                return util_1.Util.extend(o, v);
            });
        });
    }
}
function getEntityUrl(entity) {
    if (entity.hasOwnProperty("odata.editLink")) {
        // we are dealign with minimal metadata (default)
        return util_1.Util.combinePaths("_api", entity["odata.editLink"]);
    }
    else if (entity.hasOwnProperty("__metadata")) {
        // we are dealing with verbose, which has an absolute uri
        return entity.__metadata.uri;
    }
    else {
        // we are likely dealing with nometadata, so don't error but we won't be able to
        // chain off these objects
        logging_1.Logger.write("No uri information found in ODataEntity parsing, chaining will fail for this object.", logging_1.LogLevel.Warning);
        return "";
    }
}
exports.ODataRaw = new ODataRawParserImpl();
function ODataValue() {
    return new ODataValueParserImpl();
}
exports.ODataValue = ODataValue;
function ODataEntity(factory) {
    return new ODataEntityParserImpl(factory);
}
exports.ODataEntity = ODataEntity;
function ODataEntityArray(factory) {
    return new ODataEntityArrayParserImpl(factory);
}
exports.ODataEntityArray = ODataEntityArray;
/**
 * Manages a batch of OData operations
 */
class ODataBatch {
    constructor(baseUrl, _batchId = util_1.Util.getGUID()) {
        this.baseUrl = baseUrl;
        this._batchId = _batchId;
        this._requests = [];
        this._batchDependencies = Promise.resolve();
    }
    /**
     * Adds a request to a batch (not designed for public use)
     *
     * @param url The full url of the request
     * @param method The http method GET, POST, etc
     * @param options Any options to include in the request
     * @param parser The parser that will hadle the results of the request
     */
    add(url, method, options, parser) {
        let info = {
            method: method.toUpperCase(),
            options: options,
            parser: parser,
            reject: null,
            resolve: null,
            url: url,
        };
        let p = new Promise((resolve, reject) => {
            info.resolve = resolve;
            info.reject = reject;
        });
        this._requests.push(info);
        return p;
    }
    addBatchDependency() {
        let resolver;
        let promise = new Promise((resolve) => {
            resolver = resolve;
        });
        this._batchDependencies = this._batchDependencies.then(() => promise);
        return resolver;
    }
    /**
     * Execute the current batch and resolve the associated promises
     *
     * @returns A promise which will be resolved once all of the batch's child promises have resolved
     */
    execute() {
        return this._batchDependencies.then(() => this.executeImpl());
    }
    executeImpl() {
        // if we don't have any requests, don't bother sending anything
        // this could be due to caching further upstream, or just an empty batch 
        if (this._requests.length &lt; 1) {
            return Promise.resolve();
        }
        // build all the requests, send them, pipe results in order to parsers
        let batchBody = [];
        let currentChangeSetId = "";
        this._requests.map((reqInfo) => {
            if (reqInfo.method === "GET") {
                if (currentChangeSetId.length > 0) {
                    // end an existing change set
                    batchBody.push(`--changeset_${currentChangeSetId}--\n\n`);
                    currentChangeSetId = "";
                }
                batchBody.push(`--batch_${this._batchId}\n`);
            }
            else {
                if (currentChangeSetId.length &lt; 1) {
                    // start new change set
                    currentChangeSetId = util_1.Util.getGUID();
                    batchBody.push(`--batch_${this._batchId}\n`);
                    batchBody.push(`Content-Type: multipart/mixed; boundary="changeset_${currentChangeSetId}"\n\n`);
                }
                batchBody.push(`--changeset_${currentChangeSetId}\n`);
            }
            // common batch part prefix
            batchBody.push(`Content-Type: application/http\n`);
            batchBody.push(`Content-Transfer-Encoding: binary\n\n`);
            let headers = {
                "Accept": "application/json;",
            };
            if (reqInfo.method !== "GET") {
                let method = reqInfo.method;
                if (reqInfo.hasOwnProperty("options") &amp;&amp; reqInfo.options.hasOwnProperty("headers") &amp;&amp; typeof reqInfo.options.headers["X-HTTP-Method"] !== "undefined") {
                    method = reqInfo.options.headers["X-HTTP-Method"];
                    delete reqInfo.options.headers["X-HTTP-Method"];
                }
                batchBody.push(`${method} ${reqInfo.url} HTTP/1.1\n`);
                headers = util_1.Util.extend(headers, { "Content-Type": "application/json;odata=verbose;charset=utf-8" });
            }
            else {
                batchBody.push(`${reqInfo.method} ${reqInfo.url} HTTP/1.1\n`);
            }
            if (typeof pnplibconfig_1.RuntimeConfig.headers !== "undefined") {
                headers = util_1.Util.extend(headers, pnplibconfig_1.RuntimeConfig.headers);
            }
            if (reqInfo.options &amp;&amp; reqInfo.options.headers) {
                headers = util_1.Util.extend(headers, reqInfo.options.headers);
            }
            for (let name in headers) {
                if (headers.hasOwnProperty(name)) {
                    batchBody.push(`${name}: ${headers[name]}\n`);
                }
            }
            batchBody.push("\n");
            if (reqInfo.options.body) {
                batchBody.push(`${reqInfo.options.body}\n\n`);
            }
        });
        if (currentChangeSetId.length > 0) {
            // Close the changeset
            batchBody.push(`--changeset_${currentChangeSetId}--\n\n`);
            currentChangeSetId = "";
        }
        batchBody.push(`--batch_${this._batchId}--\n`);
        let batchHeaders = {
            "Content-Type": `multipart/mixed; boundary=batch_${this._batchId}`,
        };
        let batchOptions = {
            "body": batchBody.join(""),
            "headers": batchHeaders,
        };
        let client = new httpclient_1.HttpClient();
        let requestUrl = util_1.Util.makeUrlAbsolute(util_1.Util.combinePaths(this.baseUrl, "/_api/$batch"));
        return client.post(requestUrl, batchOptions)
            .then(r => r.text())
            .then(this._parseResponse)
            .then((responses) => {
            if (responses.length !== this._requests.length) {
                throw new exceptions_1.BatchParseException("Could not properly parse responses to match requests in batch.");
            }
            return responses.reduce((chain, response, index) => {
                let request = this._requests[index];
                if (!response.ok) {
                    request.reject(new Error(response.statusText));
                }
                return chain.then(_ => request.parser.parse(response).then(request.resolve).catch(request.reject));
            }, Promise.resolve());
        });
    }
    /**
     * Parses the response from a batch request into an array of Response instances
     *
     * @param body Text body of the response from the batch request
     */
    _parseResponse(body) {
        return new Promise((resolve, reject) => {
            let responses = [];
            let header = "--batchresponse_";
            // Ex. "HTTP/1.1 500 Internal Server Error"
            let statusRegExp = new RegExp("^HTTP/[0-9.]+ +([0-9]+) +(.*)", "i");
            let lines = body.split("\n");
            let state = "batch";
            let status;
            let statusText;
            for (let i = 0; i &lt; lines.length; ++i) {
                let line = lines[i];
                switch (state) {
                    case "batch":
                        if (line.substr(0, header.length) === header) {
                            state = "batchHeaders";
                        }
                        else {
                            if (line.trim() !== "") {
                                throw new exceptions_1.BatchParseException(`Invalid response, line ${i}`);
                            }
                        }
                        break;
                    case "batchHeaders":
                        if (line.trim() === "") {
                            state = "status";
                        }
                        break;
                    case "status":
                        let parts = statusRegExp.exec(line);
                        if (parts.length !== 3) {
                            throw new exceptions_1.BatchParseException(`Invalid status, line ${i}`);
                        }
                        status = parseInt(parts[1], 10);
                        statusText = parts[2];
                        state = "statusHeaders";
                        break;
                    case "statusHeaders":
                        if (line.trim() === "") {
                            state = "body";
                        }
                        break;
                    case "body":
                        responses.push((status === 204) ? new Response() : new Response(line, { status: status, statusText: statusText }));
                        state = "batch";
                        break;
                }
            }
            if (state !== "status") {
                reject(new exceptions_1.BatchParseException("Unexpected end of input"));
            }
            resolve(responses);
        });
    }
}
exports.ODataBatch = ODataBatch;
class TextFileParser {
    parse(r) {
        return r.text();
    }
}
exports.TextFileParser = TextFileParser;
class BlobFileParser {
    parse(r) {
        return r.blob();
    }
}
exports.BlobFileParser = BlobFileParser;
class JSONFileParser {
    parse(r) {
        return r.json();
    }
}
exports.JSONFileParser = JSONFileParser;
class BufferFileParser {
    parse(r) {
        if (util_1.Util.isFunction(r.arrayBuffer)) {
            return r.arrayBuffer();
        }
        return r.buffer();
    }
}
exports.BufferFileParser = BufferFileParser;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AttachmentFile.html">AttachmentFile</a></li><li><a href="AttachmentFiles.html">AttachmentFiles</a></li><li><a href="CachingConfigurationProvider.html">CachingConfigurationProvider</a></li><li><a href="ConsoleListener.html">ConsoleListener</a></li><li><a href="ContentType.html">ContentType</a></li><li><a href="ContentTypes.html">ContentTypes</a></li><li><a href="CurrentUser.html">CurrentUser</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="Feature.html">Feature</a></li><li><a href="Features.html">Features</a></li><li><a href="FetchClient.html">FetchClient</a></li><li><a href="Field.html">Field</a></li><li><a href="FieldLink.html">FieldLink</a></li><li><a href="FieldLinks.html">FieldLinks</a></li><li><a href="Fields.html">Fields</a></li><li><a href="File.html">File</a></li><li><a href="Files.html">Files</a></li><li><a href="Folder.html">Folder</a></li><li><a href="Folders.html">Folders</a></li><li><a href="Form.html">Form</a></li><li><a href="Forms.html">Forms</a></li><li><a href="FunctionListener.html">FunctionListener</a></li><li><a href="Item.html">Item</a></li><li><a href="Items.html">Items</a></li><li><a href="List.html">List</a></li><li><a href="Lists.html">Lists</a></li><li><a href="Logger.html">Logger</a></li><li><a href="Navigation.html">Navigation</a></li><li><a href="NavigationNodes.html">NavigationNodes</a></li><li><a href="NodeFetchClient.html">NodeFetchClient</a></li><li><a href="ODataBatch.html">ODataBatch</a></li><li><a href="PagedItemCollection.html">PagedItemCollection</a></li><li><a href="PnPClientStorage.html">PnPClientStorage</a></li><li><a href="PnPClientStorageWrapper.html">PnPClientStorageWrapper</a></li><li><a href="ProcessHttpClientResponseException.html">ProcessHttpClientResponseException</a></li><li><a href="Queryable.html">Queryable</a></li><li><a href="QueryableCollection.html">QueryableCollection</a></li><li><a href="QueryableInstance.html">QueryableInstance</a></li><li><a href="Rest.html">Rest</a></li><li><a href="RoleAssignment.html">RoleAssignment</a></li><li><a href="RoleAssignments.html">RoleAssignments</a></li><li><a href="RoleDefinitions.html">RoleDefinitions</a></li><li><a href="Search.html">Search</a></li><li><a href="SearchResult.html">SearchResult</a></li><li><a href="SearchResults.html">SearchResults</a></li><li><a href="Settings.html">Settings</a></li><li><a href="Site.html">Site</a></li><li><a href="SiteGroup.html">SiteGroup</a></li><li><a href="SiteGroups.html">SiteGroups</a></li><li><a href="SiteUser.html">SiteUser</a></li><li><a href="SiteUsers.html">SiteUsers</a></li><li><a href="SPListConfigurationProvider.html">SPListConfigurationProvider</a></li><li><a href="SPRequestExecutorClient.html">SPRequestExecutorClient</a></li><li><a href="Subscription.html">Subscription</a></li><li><a href="Subscriptions.html">Subscriptions</a></li><li><a href="Version.html">Version</a></li><li><a href="Versions.html">Versions</a></li><li><a href="View.html">View</a></li><li><a href="Views.html">Views</a></li><li><a href="Web.html">Web</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AddFieldOptions">AddFieldOptions</a></li><li><a href="global.html#AddFieldOptions%255Bundefined%255D">AddFieldOptions[undefined]</a></li><li><a href="global.html#config">config</a></li><li><a href="global.html#ControlMode">ControlMode</a></li><li><a href="global.html#default">default</a></li><li><a href="global.html#FieldTypes">FieldTypes</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#LogLevel">LogLevel</a></li><li><a href="global.html#PrincipalType">PrincipalType</a></li><li><a href="global.html#QueryPropertyValueType">QueryPropertyValueType</a></li><li><a href="global.html#readBlobAs">readBlobAs</a></li><li><a href="global.html#readBlobAsArrayBuffer">readBlobAsArrayBuffer</a></li><li><a href="global.html#readBlobAsText">readBlobAsText</a></li><li><a href="global.html#ReorderingRuleMatchType">ReorderingRuleMatchType</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#SortDirection">SortDirection</a></li><li><a href="global.html#sp">sp</a></li><li><a href="global.html#storage">storage</a></li><li><a href="global.html#util">util</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Jan 23 2017 13:00:46 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
